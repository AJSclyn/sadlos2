/************************************************************************
 * Copyright 2007-2015 - General Electric Company, All Rights Reserved
 *
 * Project: SADL
 *
 * Description: The Semantic Application Design Language (SADL) is a
 * language for building semantic models and expressing rules that
 * capture additional domain knowledge. The SADL-IDE (integrated
 * development environment) is a set of Eclipse plug-ins that
 * support the editing and testing of semantic models using the
 * SADL language.
 *
 * This software is distributed "AS-IS" without ANY WARRANTIES
 * and licensed under the Eclipse Public License - v 1.0
 * which is available at http://www.eclipse.org/org/documents/epl-v10.php
 *
 ***********************************************************************/

grammar com.ge.research.sadl.SADL hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate sADL "http://www.ge.com/research/sadl/SADL"

Model :
    'uri' baseUri=STRING ('alias' alias=NAME)? ('version' version=STRING)? 
    	Annotation* EOS 
    imports+=Import*
    elements+=ModelElement*;
    
fragment Annotation :
	'(' annType+=('alias'|'note') annContent+=STRING (',' annContent+=STRING)* ')'
;

Import :
    'import' importURI=STRING ('as' alias=NAME)? EOS;

// The various kinds of elements that make up the body of a model.
ModelElement :
    	Statement
    ;

// These are the things that translate directly to OWL.
Statement :
        ClassDeclaration
;

// TypeReferences
TypeReference returns TypeReference:
    UnionType
;

UnionType returns TypeReference:
	IntersectionType ({UnionType.left=current} (','|'or') right=IntersectionType)*
;

IntersectionType returns TypeReference:
	PrimaryTypeReference ({IntersectionType.left=current} ('and') right=PrimaryTypeReference)*
;

PrimaryTypeReference returns TypeReference:
	{SimpleTypeReference} type=[ClassDeclaration|NAME]
	| RestrictedTypeReference
	| PrimitiveDataType
	| '{' TypeReference '}'
;

RestrictedTypeReference :
	'(' type=TypeReference cond=Condition ')'
;

PrimitiveDataType returns TypeReference :
	primitiveType=DataType
;

enum DataType :
    string | boolean | decimal | int | long | float | double | duration | dateTime | time | date |
    gYearMonth | gYear | gMonthDay | gDay | gMonth | hexBinary | base64Binary | anyURI | data;

// Classes may be declared in many ways.
ClassDeclaration:
	(name=NAME Annotation* 'is' 'a' ('top-level'? 'class'
									| 'type' 'of' superType=TypeReference)
								(','? 'must' 'be' 'one' 'of' '{' instanceDeclarations+=InstanceDeclaration (',' instanceDeclarations+=InstanceDeclaration)* '}')?
	| '{' multiDeclarations+=MultiClassDeclarationPart (','  multiDeclarations+=MultiClassDeclarationPart)*'}' 
						   'are' ('top-level'? 'classes'
									| 'types' 'of' superType=TypeReference))
	describedBy+=AddlClassInfo* EOS;

MultiClassDeclarationPart returns ClassDeclaration:
	name=NAME Annotation*
;

InstanceDeclaration :
	name=NAME
;

// Class declarations may also describe the class's properties.
AddlClassInfo returns Property:
    	','? 'described' 'by' name=NAME (type=TypeInformation|restriction=Condition);

// ... a single value ...
// ... a List of values ...
// ... Lists of values ...
// ... values ...
TypeInformation :
    ('has'|'with') ('a' singleValued?='single' 'value'|('a' 'List'|'Lists') 'of' 'values'|'values') 'of' 'type' type=TypeReference;

// These articles can appear before the property name and are indicative of the functionality of the property or
//	the cardinality of the property on the class
AnArticle :
	IndefiniteArticle | DefiniteArticle;

IndefiniteArticle :
	'A'|'a'|'An'|'an';

DefiniteArticle :
	'The'|'the';

Condition :
    	AllValuesCondition
    |   HasValueCondition
    |   CardinalityCondition
    ;

AllValuesCondition :
	'only' ('has'|'with') 'values' 'of' 'type' type=TypeReference;

HasValueCondition :
	'always' ('has'|'with') 'value' restriction=ExplicitValue;

CardinalityCondition :
	('has'|'with') 
	('at' operator=('least'|'most') |'exactly') 
	cardinality=(NUMBER|'one') ('value'|'values') 
	('of' 'type' type=TypeReference | 'each' 'of' 'types' type=TypeReference)?;


ExplicitValue :
//TODO		instName=ResourceByName		// e.g., George
		litValue=LiteralValue		// e.g., 38.186111
	|	valueList='[' row=ValueRow ']'
	|	term='PI'					// PI
	|	term='known'				// known
    ;
    
LiteralValue :
        literalNumber=NUMBER
    |   literalString=STRING
    |   literalBoolean=('true'|'false');

ValueRow :
	explicitValues+=ExplicitValue (',' explicitValues+=ExplicitValue)*;	// e.g., George, 23, "Purple", 38.186111


// NAME should match an optional namespace followed by a local name (separated
// from the namespace by a colon character).  We also need to accept legal URI
// fragments as local names.  In particular, we need names like X.509 to work.
NAME hidden() :
   ID (':' ID)? (('-'|'.'|'~'|'%') NAME_FRAGMENT)*;

NAME_FRAGMENT hidden():
	ID | UNSIGNED_NUMBER ID?
;

// NUMBER matches both integral and floating point numbers.
NUMBER hidden() :
  '-'? UNSIGNED_NUMBER
;

terminal UNSIGNED_NUMBER:
     ('0'..'9')+
   | ('0'..'9')+ '.' ('0'..'9')* (('e'|'E') ('+'|'-')? ('0'..'9')+)?
   |             '.' ('0'..'9')+ (('e'|'E') ('+'|'-')? ('0'..'9')+)?
   | ('0'..'9')+                  ('e'|'E') ('+'|'-')? ('0'..'9')+
;

// EOS matches one whitespace character or EOF after the period in order to
// disambiguate the end of sentence period from periods in names.
terminal EOS :
    '.' (' '|'\t'|'\r'|'\n'|EOF);

terminal ID:
	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	
terminal STRING:
	'"' ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | '"'))* '"' |
	"'" ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | "'"))* "'";
	
terminal ML_COMMENT:
	'/*'->'*/';
	
terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;
	
terminal WS:
	(' ' | '\t' | '\r' | '\n')+;
terminal ANY_OTHER:
	.;
	